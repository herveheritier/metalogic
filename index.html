<html>
    <style>
        body {
            background-color: black;
            color: gray;
            font-size: 9pt;
            display: inline-block;
            position: relative;
            left: 40px;
            font-family: 'Courier New', Courier, monospace;
            /*white-space: pre-wrap;*/

        }
        h1 {
            color: aqua;
            font-size: 12pt;
            position: relative;
            left: -40px;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif
        }
        h2 {
            color: greenyellow;
            font-size: 11pt;
            position: relative;
            left: -30px;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif
        }
        h3 {
            color: white;
            font-size: 10pt;
            position: relative;
            left: -20px;
        }
    </style>
    <body>
        <h1>Test de la classe Sets</h1>
        Pour visualiser la class, consulter le source de la page<br/>
    </body>
    <script>

/*************************************************
*
* manipulation d'ensembles basé sur la classe Set
*
**************************************************/
class Sets {

    constructor() { 
        this.setsMap = new Map()
    }

    // ajoute un nouvel ensemble à l'instance
    //
    // Attention, méthode d'instance
    //
    newSet(name,elementArray) {
        this.setsMap.set(name,elementArray)
        return this.setsMap.get(name)
    }

    // retourne le résulat de la comparaison de 2 ensembles
    // true si les ensembles sont identiques
    // false sinon
    static areEqual(set1,set2) {
        var array1 = [...set1]
        var array2 = [...set2]
        return array1.length === array2.length && array1.sort().every(function(value, index) { return value === array2.sort()[index]});
    }

    // retourne une liste d'élément composé des éléments des ensembles fournis
    // les éléments présents dans plusieurs ensembles ne sont présents qu'une seule fois dans l'ensemble obtenu
    // "ensembleArray" est soit un tableau, soit une liste d'arguments où chacun est un ensemble
    static union(ensembleArray) {
        if(arguments.length>1) ensembleArray = Array.from(arguments)
        return ensembleArray.reduce( (a,e) => {
            var s0 = new Set([...e])
            return new Set([...a, ...s0])
        },new Set([]))
    }

    // vérifie que la valeur est composée d'élément appartenant à l'ensemble
    // valeur peut-être un String, un Array ou un Set
    // si valeur est un String, chaque caractère du string est un élément
    // si valeur est un Array ou un Set, ce sont les éléments qui sont recherchés, pas les caractères qui les composent
    static isInclude(ensemble,valeur) {
        //return Array.from(valeur).reduce((a,c) => a && ensemble.includes(c),true)
        var e0 = [...new Set([...ensemble])]
        var v0 = [...new Set([...valeur])]
        return v0.reduce((a,c) => a && e0.includes(c),true)
    }

    // genere une tableau de n élément appartenant à l'ensemble
    static generate(ensemble,n) {
        //return Array.from(Array(n).keys()).map((a,c)=> ensemble[Math.floor(Math.random()*ensemble.length)])
        var s0 = new Set([...ensemble])
        var a0 = Array.from(s0)
        return Array.from(Array(n).keys()).map((a,c)=> a0[Math.floor(Math.random()*a0.length)])
    }

    // retourne un tableau des noms d'ensembles auxquels appartiennent tous les éléments composants valeur
    // valeur peut-être un String, un Array ou un Set
    // si valeur est un String, chaque caractère du string est un élément
    // si valeur est un Array ou un Set, ce sont les éléments qui sont recherchés, pas les caractères qui les composent
    identifySuperset(valeur) { 
        var res = []
        var v0 = [...new Set([...valeur])]
        this.setsMap.forEach((val,key,map) => {
            var a0 = [...new Set([...val])]
            if(Sets.isInclude(a0,v0)) res.push(key) 
        })
        return res
    }

    // intersection entre 2 ensembles
    static intersection(ensemble1,ensemble2) {
        var e1 = [...new Set([...ensemble1])]
        var e2 = [...new Set([...ensemble2])]
        return e1.filter((c) => e2.includes(c) )
    }

    // ce qui existe seulement dans le 1er ensemble
    static outerLeft(ensemble1,ensemble2) {
        var e1 = [...new Set([...ensemble1])]
        var e2 = [...new Set([...ensemble2])]
        return e1.filter((c) => !e2.includes(c) )
    }

    // compare 2 ensembles
    // retourne un objet résultat de la comparaison
    // { etat : symboles représentant le résultat de la comparaison
    //   court : libellé court représentant le résultat de la comparaison
    //   long : libellé long représentant le résultat de la comparaison
    //   intersection : sous-ensemble des élément communs
    //   seul1 : sous-ensemble des éléments présent seulement dans le 1er ensemble
    //   seul2 : sous-ensemble des éléments présent seulement dans le 2nd ensemble
    //   distincts : sous-ensemble des tous les éléments (union)
    // }
    static compare(ensemble1,ensemble2) {
        var e1 = [...new Set([...ensemble1])]
        var e2 = [...new Set([...ensemble2])]
        var distincts = [...new Set(e1.concat(e2))]
        var l1 = e1.length
        var l2 = e2.length
        var ld = distincts.length
        var etat, court, long
        var intersection = Sets.intersection(ensemble1,ensemble2)
        var seul1 = Sets.outerLeft(ensemble1,ensemble2)
        var seul2 = Sets.outerLeft(ensemble2,ensemble1)
        if(l1==ld & l2==ld) 
            etat = "1=2",
            court = "1 = 2", 
            long = "ensemble 1 et ensemble 2 identiques"
        else if(l1==ld) 
            etat = "1>2",
            court = "1 \u2283 2",
            long = "ensemble 2 inclus dans ensemble 1"
        else if(l2==ld) 
            etat = "1<2",
            court = "1 \u2282 2", 
            long = "ensemble 1 inclus dans ensemble 2"
        else if((l1+l2)==ld) 
            etat = "1#2",
            court = "1 \u2260 2", 
            long = "ensemble 1 et ensemble 2 sont disjointes"
        else 
            etat = "1~2",
            court = "1 \u2229 2 = "+(l1+l2-ld), 
            long = "ensemble 1 et ensemble 2 ont "+(l1+l2-ld)+" elements communs, " + distincts.length + " elements distincts, " + seul1.length + " elements seulement dans l'ensemble 1, " + seul2.length + " elements seulement dans l'ensemble 2"
        return { etat : etat, court : court, long : long, intersection : intersection, seul1 : seul1, seul2 : seul2, distincts : distincts }
    }

    // recherche l'ensemble référencé dans le tableau "ensembleArray" qui est contenu dans toutes les autres ensembles du tableau
    // "ensembleArray" est soit un tableau, soit une liste d'arguments ; dans les 2 cas chaque c'est une list d'ensembles
    // pour chaque ensemble on peut donner son nom (string) ou l'objet ENSEMBLE.xxxxxx
    // retourne un nom d'ensemble ou null si aucun ensemble ne peut-être contenu dans les autres
    //
    // Attention, méthode d'instance
    //
    // exemples d'utilisation :
    // Sets.minimalCommonSet(Sets.identifySuperset(Sets.outerLeft(ENSEMBLE.FORMULE,ENSEMBLE.CHIFFRE))) ==> "ARITHMETIQUE"
    // - l'ensemble ARITHMETIQUE est celle qui contient tous les elements de l'ensemble FORMULE de laquelle on a retiré les éléments de l'ensemble CHIFFRE
    // Sets.minimalCommonSet(Sets.identifySuperset('PersonnageNumeroUn')) ==> "LETTRE"
    // - tous les caractère de la chaine testée sont des éléments de l'ensemble LETTRE
    // Sets.minimalCommonSet(Sets.identifySuperset(['a','8','+'])) ==> "BASE64"
    // - l'ensemble BASE64 est le plus petit ensemble contenant les éléments du tableau
    // Sets.minimalCommonSet([ENSEMBLE.DIVISE,ENSEMBLE.CHIFFRE,ENSEMBLE.FORMULE]) ==> null
    // - aucun ensemble n'est contenu dans toutes les autres
    minimalCommonSet(ensembleArray) {
        if(arguments.length>1) ensembleArray = Array.from(arguments)
        var l = ensembleArray.length
        if(l==0) return null
        var res = this.getEnsemble(ensembleArray[0])
        if(l!=1) for(var i=1;i<l;i++) {
            var res = this.getEnsemble(Sets.intersection(res,this.getEnsemble(ensembleArray[i])))
            if(res===undefined) return null
        }
        return res
    }

    // vérifie si ce qui lui est passé est bien un ensemble appatenant à l'instance de Sets
    //
    // Attention, méthode d'instance
    //
    isSet(ensemble) {
        // return Array.isArray(ensemble) ? Object.getOwnPropertyNames(ENSEMBLE).find(e => ensemble==ENSEMBLE[e])!=undefined : false
        if(Array.prototype.isPrototypeOf(ensemble) ||Set.prototype.isPrototypeOf(ensemble)) {
            var res = undefined
            this.setsMap.forEach((val,key,map) => { if(Sets.areEqual(ensemble,val)) res=key })
            if(res!==undefined) return true
            return false
        }
        return this.setsMap.has(ensemble)
    }

    // retourne le nom de l'ensemble qui lui est passée sinon undefined
    // exemple :
    // Sets.getName(ENSEMBLE.LETTRE) ==> "LETTRE"
    // Sets.getName(ENSEMBLE.FAUX) ==> undefined
    // Ensemble.getName('toto') ==> undefined
    //
    // Attention, méthode d'instance
    //
    getName(ensemble) {
        //if(Array.isArray(ensemble)) ensemble = Object.getOwnPropertyNames(ENSEMBLE).find(e => Sets.compare(ensemble,ENSEMBLE[e]).etat=="1=2")
        var res = undefined
        if(Array.prototype.isPrototypeOf(ensemble)) this.setsMap.forEach((val,key,map) => { if(Sets.areEqual(new Set([...ensemble]),val)) res=key })
        else if(Set.prototype.isPrototypeOf(ensemble)) this.setsMap.forEach((val,key,map) => { if(Sets.areEqual(ensemble,val)) res=key })
        else if(this.setsMap.has(ensemble)) res = ensemble
        return res
    }

    // vérifie que le nom ou l'ensemble qui lui est passée existe et retourne l'ensemble
    //
    // Attention, méthode d'instance
    //
    getEnsemble(ensemble) {
        var res
        var e = this.getName(ensemble)
        if(e!==undefined) return this.setsMap.get(e)
        if(Array.prototype.isPrototypeOf(ensemble)) return [...ensemble]
        if(Set.prototype.isPrototypeOf(ensemble)) return ensemble
        return undefined
    }

    // retourne un ensemble à partir d'un chaine
    // chaque caractère devient un élément
    static fromString(chaine) {
        return new Set(Array.from(chaine))
    }
    
}

//********************************** pour tests *******************************//
//********************************** pour tests *******************************//
//********************************** pour tests *******************************//
//********************************** pour tests *******************************//
//********************************** pour tests *******************************//

var testCount = 0
var testFailed = 0

/****************************************************************
* fonction de pilotage des tests
* ev : string du code a évaluer
* attempt : valeur résultat attendue 
* validFunc (optionnelle) : fonction de validation
* la fonction de validation est réalisée ssi attempt est à null
*
* si le test est ok, l'évaluation est rejouée 1000 fois 
* pour mesurer les performances
******************************************************************/ 
function test(ev,attempt,validFunc=null) {
    testCount++
    console.group(ev)
    var res = eval(ev)
    //console.log(res)
    var ok = false
    if(validFunc!=null) {
        var vf = validFunc(res)
        if(Set.prototype.isPrototypeOf(res)) console.log([...res])
        else if(Array.prototype.isPrototypeOf(res)) console.log(res)
        else console.log(JSON.stringify(res,null,4))
        if(!vf) testFailed++ 
        else ok = true
    }
    else if(Array.prototype.isPrototypeOf(attempt) || Set.prototype.isPrototypeOf(attempt)) {
        if(Set.prototype.isPrototypeOf(res)) console.log([...res])
        else if(Array.prototype.isPrototypeOf(res)) console.log(res)
        else console.log(res)
        if(!Sets.areEqual(res,new Set(attempt))) testFailed++
        else ok = true
    }
    else if(res!=attempt) console.log(res), testFailed++
    else console.log(res), ok = true

    if(ok) {
        console.log("Test passed... ")
        var t0 = performance.now()
        for(var i =0;i<1000;i++) eval(ev)
        var t1 = performance.now()
        console.log((t1-t0).toFixed(2)+"ms elapsed for 1000 executions")
    }
    else console.log("Test failed... ")
    
    console.groupEnd()
}

// compte-rendu de test

function testResults() {
    console.group('****** Tests Report *******')
    console.log("tests executed : "+testCount)
    console.log("tests passed   : "+(testCount-testFailed))
    console.log("tests failed   : "+testFailed)
    console.groupEnd()
}

// reroutage des fonctions log, group et groupEnd de l'objet console

var level = 1;

(function(){
    var oldLog = console.log;
    console.log = function (message) {
        var pre = document.createElement('pre')
        pre.appendChild(document.createTextNode(message))
        document.querySelector("body").appendChild(pre)
        //document.querySelector("body").appendChild(document.createElement('br'))
        oldLog.apply(console, arguments);
    };
    var oldGroup = console.group
    console.group = function (message) {
        var h = document.createElement('h'+level)
        h.appendChild(document.createTextNode(message))
        document.querySelector("body").appendChild(h)
        oldGroup.apply(console, arguments);
        level++
    }
    var oldGroupEnd = console.groupEnd
    console.groupEnd = function () {
        level--
        oldGroupEnd.apply(console, arguments)
    }
})();

// déclaration des ensembles utilisés dans le test

const ENSEMBLE = new Sets()

ENSEMBLE.MINUSCULE            = ENSEMBLE.newSet(    "MINUSCULE"           ,Sets.fromString(    'abcdefghijklmnopqrstuvwxyz'            ))
ENSEMBLE.MAJUSCULE            = ENSEMBLE.newSet(    "MAJUSCULE"           ,Sets.fromString(    'ABCDEFGHIJKLMNOPQRSTUVWXYZ'            ))
ENSEMBLE.CHIFFRE              = ENSEMBLE.newSet(    "CHIFFRE"             ,Sets.fromString(    '0123456789'                            ))
ENSEMBLE.PLUS                 = ENSEMBLE.newSet(    "PLUS"                ,Sets.fromString(    '+'                                     ))
ENSEMBLE.DIVISE               = ENSEMBLE.newSet(    "DIVISE"              ,Sets.fromString(    '/'                                     ))
ENSEMBLE.MOINS                = ENSEMBLE.newSet(    "MOINS"               ,Sets.fromString(    '-'                                     ))
ENSEMBLE.MULTIPLIE            = ENSEMBLE.newSet(    "MULTIPLIE"           ,Sets.fromString(    '*'                                     ))
ENSEMBLE.PARENTHESE           = ENSEMBLE.newSet(    "PARENTHESE"          ,Sets.fromString(    '()'                                    ))
ENSEMBLE.ESPACE               = ENSEMBLE.newSet(    "ESPACE"              ,Sets.fromString(    ' '                                     ))
ENSEMBLE.PONCTUATION          = ENSEMBLE.newSet(    "PONCTUATION"         ,Sets.fromString(    ',;.:!?\'"'                             ))
ENSEMBLE.SIGNE                = ENSEMBLE.newSet(    "SIGNE"               ,Sets.union(         ENSEMBLE.PLUS,
                                                                                               ENSEMBLE.MOINS                          ))
ENSEMBLE.ARITHMETIQUE         = ENSEMBLE.newSet(    "ARITHMETIQUE"        ,Sets.union(         ENSEMBLE.SIGNE,
                                                                                               ENSEMBLE.MULTIPLIE,
                                                                                               ENSEMBLE.DIVISE,
                                                                                               ENSEMBLE.PARENTHESE                     ))
ENSEMBLE.LETTRE               = ENSEMBLE.newSet(    "LETTRE"              ,Sets.union(         ENSEMBLE.MINUSCULE,
                                                                                               ENSEMBLE.MAJUSCULE                      ))
ENSEMBLE.CARACTERE            = ENSEMBLE.newSet(    "CARACTERE"           ,Sets.union(         ENSEMBLE.LETTRE,
                                                                                               ENSEMBLE.CHIFFRE,
                                                                                               ENSEMBLE.ARITHMETIQUE,
                                                                                               ENSEMBLE.ESPACE,
                                                                                               ENSEMBLE.PONCTUATION                    ))
ENSEMBLE.FORMULE              = ENSEMBLE.newSet(    "FORMULE"             ,Sets.union(         ENSEMBLE.CHIFFRE,
                                                                                               ENSEMBLE.ARITHMETIQUE                   ))
ENSEMBLE.BASE64               = ENSEMBLE.newSet(    "BASE64"              ,Sets.union(         ENSEMBLE.MAJUSCULE,
                                                                                               ENSEMBLE.MINUSCULE,
                                                                                               ENSEMBLE.CHIFFRE,
                                                                                               ENSEMBLE.PLUS,
                                                                                               ENSEMBLE.DIVISE                         ))

// série de tests

console.clear()
console.group('*** Tests series ***')
console.group('sets used for those tests')
ENSEMBLE.setsMap.forEach((v,k,m) => console.log(k+" : "+[...v]))
console.groupEnd()
console.group('union')
test("Sets.union(['a','b','c'],['d','e','f'])", ["a", "b", "c", "d", "e", "f"])
test("Sets.union(['a','b','c'],ENSEMBLE.CHIFFRE)", ["a", "b", "c", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"])
test("Sets.union(ENSEMBLE.CHIFFRE,['d','e','f'])", ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "d", "e", "f"])
test("Sets.union(['1','2','c'],ENSEMBLE.CHIFFRE)", ["1", "2", "c", "0", "3", "4", "5", "6", "7", "8", "9"])
test("Sets.union(ENSEMBLE.CHIFFRE,['d','5','f'])", ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "d", "f"])
test("Sets.union(ENSEMBLE.CHIFFRE,ENSEMBLE.SIGNE)", ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "-"])
test("Sets.union(ENSEMBLE.SIGNE,ENSEMBLE.CHIFFRE)", ["+", "-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"])
console.groupEnd()
console.group('isInclude')
test("Sets.isInclude(ENSEMBLE.LETTRE,['a','d'])", true)
test("Sets.isInclude(ENSEMBLE.MAJUSCULE,['A','d'])", false)
console.groupEnd()
console.group('generate')
test("Sets.generate(ENSEMBLE.LETTRE,18)",null,(e)=>e.length==18)
console.groupEnd()
console.group('identifySuperset')
test("ENSEMBLE.identifySuperset(['1','a'])",["CARACTERE", "BASE64"])
test("ENSEMBLE.identifySuperset(ENSEMBLE.SIGNE)",["SIGNE", "ARITHMETIQUE", "CARACTERE", "FORMULE"])
test("ENSEMBLE.identifySuperset(Sets.fromString('star'))",["MINUSCULE", "LETTRE", "CARACTERE", "BASE64"])
console.groupEnd()
console.group('intersection')
test("Sets.intersection(['a','b','c','d'],['r','a','p','i','d','e'])", ["a", "d"])
test("Sets.intersection(ENSEMBLE.FORMULE,ENSEMBLE.BASE64)", ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"])
test("Sets.intersection(Sets.fromString('Blabla Car'),ENSEMBLE.MAJUSCULE)", ["B", "C"])
console.groupEnd()
console.group('outerLeft')
test("Sets.outerLeft(['a','b','c','d'],['r','a','p','i','d','e'])", ["b", "c"])
test("Sets.outerLeft(['r','a','p','i','d','e'],['a','b','c','d'])", ["r", "p", "i", "e"])
test("Sets.outerLeft(ENSEMBLE.FORMULE,ENSEMBLE.BASE64)", ["-", "*", "(", ")"])
test("Sets.outerLeft(Sets.fromString('Blabla Car'),ENSEMBLE.MAJUSCULE)", ["l", "a", "b", " ", "r"])
console.groupEnd()
console.group('compare')
test("Sets.compare(['a','b','c','d'],['r','a','p','i','d','e'])",null,(e)=>e.etat=="1~2"&&e.distincts.length==8&&e.intersection.length==2&&e.seul1.length==2&&e.seul2.length==4)
test("Sets.compare(ENSEMBLE.BASE64,ENSEMBLE.ARITHMETIQUE)",null,(e)=>e.etat=="1~2"&&e.distincts.length==68&&e.intersection.length==2&&e.seul1.length==62&&e.seul2.length==4)
console.groupEnd()
console.group('minimalCommonSet')
test("ENSEMBLE.minimalCommonSet(ENSEMBLE.identifySuperset(['1','a']))",null,(e)=>ENSEMBLE.getName(e)=="BASE64")
test("ENSEMBLE.minimalCommonSet(ENSEMBLE.identifySuperset(ENSEMBLE.SIGNE))",null,(e)=>ENSEMBLE.getName(e)=="SIGNE")
test("ENSEMBLE.minimalCommonSet(ENSEMBLE.identifySuperset(Sets.fromString('star')))",null,(e)=>ENSEMBLE.getName(e)=="MINUSCULE")
test("ENSEMBLE.minimalCommonSet(ENSEMBLE.identifySuperset(Sets.outerLeft(ENSEMBLE.FORMULE,ENSEMBLE.CHIFFRE)))",null,(e)=>ENSEMBLE.getName(e)=="ARITHMETIQUE")
test("ENSEMBLE.minimalCommonSet(ENSEMBLE.LETTRE,ENSEMBLE.CHIFFRE)",[])
test("ENSEMBLE.minimalCommonSet(ENSEMBLE.BASE64,ENSEMBLE.LETTRE)",null,(e)=>ENSEMBLE.getName(e)=="LETTRE")
test("ENSEMBLE.minimalCommonSet(ENSEMBLE.BASE64,ENSEMBLE.ARITHMETIQUE)",["+","/"])
console.groupEnd()
console.group('isSet')
test("ENSEMBLE.isSet(ENSEMBLE.PONCTUATION)",true)
test("ENSEMBLE.isSet(['1','2','3','4','5','6','7','8','9','0'])",true)
test("ENSEMBLE.isSet(['a','b','c'])",false)
console.groupEnd()
console.group('getName')
test("ENSEMBLE.getName(ENSEMBLE.LETTRE)","LETTRE")
test("ENSEMBLE.getName(ENSEMBLE.FAUX)",undefined)
test("ENSEMBLE.getName(['0','1','2','3','4','5','6','7','8','9'])","CHIFFRE")
test("ENSEMBLE.getName('toto')",undefined)
console.groupEnd()
console.group('getEnsemble')
test("ENSEMBLE.getEnsemble(ENSEMBLE.LETTRE)",ENSEMBLE.LETTRE)
test("ENSEMBLE.getEnsemble(ENSEMBLE.FAUX)",undefined)
test("ENSEMBLE.getEnsemble('CHIFFRE')",ENSEMBLE.CHIFFRE)
test("ENSEMBLE.getEnsemble('toto')",undefined)
console.groupEnd()
console.groupEnd()

// résultat comptage

testResults()

    </script>
</html>